% This is a LaTeX file. It is a text file that is compiled
% by a program called LaTeX into a pretty PDF file.
% If you're viewing this file in Overleaf, you'll see that PDF
% in the window to the right.
%
% This file is for typesetting YOUR ANSWERS to this homework assignment.
% The LaTeX macro language is complicated, so we have inserted lots of
% documenting comments into the file. Comments start with '%'
% and continue to the end of the line. In Overleaf's edit window, they
% are colored green.
%
% Comments prefixed with 'Student:' are relevant to students. Skip any-
% thing else you don't understand, or ask me.

\documentclass{article}
%% This is some font management depending on the TeX “engine” being used.
%% Nothing to worry about.
\usepackage{ifxetex}
\ifxetex
  \usepackage{fontspec}
\else
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{lmodern}
\fi

%% Student: These lines describe some document metadata.
\title{Problem Set 5}
\usepackage{etoolbox}
\makeatletter\preto{\@title}{Answers to }\makeatother
\author{%
%% Student: change the next line to your name!
    Hongyi Zheng
\\  CSCI-UA 310 Basic Algorithms
}

%% These lines set up the question, answer, and solution environments.
\usepackage{amsthm}
\usepackage{amssymb}
\theoremstyle{plain}
\newtheorem{question}{Question}

\newenvironment{answer}[1][Answer]
    {\begin{proof}[#1]{$ $}\renewcommand\qedsymbol{$\vartriangle$}}
    {\end{proof}}
\newenvironment{solution}[1][Solution]
    {\begin{proof}[#1]{$ $}\renewcommand\qedsymbol{$\blacktriangleup$}}
    {\end{proof}}
\makeatletter
    \newcommand{\stepenumdepth}{\advance\@enumdepth\@ne}
\makeatother
\AtBeginEnvironment{question}{\stepenumdepth}
\AtBeginEnvironment{answer}{\stepenumdepth}
\AtBeginEnvironment{solution}{\stepenumdepth}

\usepackage{amsmath}
\usepackage{siunitx}
\DeclareSIUnit{\pound}{lb}
\usepackage{bm}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{caption,subcaption}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{enumerate}
%% This is the beginning of the part of the file that describes
%% the actual text of the document.
%% That's why it says `\begin{document}' below. :-)
\begin{document}
\maketitle


\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{equation*}
        \begin{aligned}
            P(cancer \mid positive) &= \frac{P(positive \mid cancer)P(cancer)}{P(positive \mid cancer)P(cancer) + P(positive \mid no\,cancer)P(no\,cancer)} \\
            &= \frac{0.95 * 0.02}{0.95 * 0.02 + 0.98 * 0.1} \\
            &= \frac{0.019}{0.117} = 16.2\%
        \end{aligned}
    \end{equation*}
\end{answer}

\begin{question}
\end{question}

\begin{answer}
     \begin{equation*}
         \begin{aligned}
             E(winning) =& -1 * P(winning = -1) + 1 * P(winning = 1) \\
             &+ 3 * P(winning = 3) + 5 * P(winning = 5)\\
             =& -\frac{125}{216} + \frac{75}{216} + 3 * \frac{15}{216} + 5 * \frac{1}{216} \\
             =& 0
         \end{aligned}
     \end{equation*}
     It is a fair game.
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
        Use induction to prove this is true.
        \begin{enumerate}
            \item When $n=1$, when tossing this coin, the probability of getting an odd number of head is $\displaystyle\frac{1}{2*1 + 1} = \frac{1}{3}$, this statement is true when $n = 1$.
            \item Suppose this statement is true for $n = k$, then for $n = k + 1$, the probability of having odd number of head is:
            \begin{equation*}
                \begin{aligned}
                    P(odd \mid k + 1\,toss) =& P(odd \mid k\,toss)P(k + 1\, toss = tail) \\
                    &+ P(even \mid k\,toss)P(k + 1\, toss = head) \\
                    =& \frac{k}{2k + 1} * (1 - \frac{1}{2(k + 1) + 1}) + (1 - \frac{k}{2k + 1}) * \frac{1}{2(k + 1) + 1} \\
                    =& \frac{k(2k + 2) + (k + 1)}{(2k + 1)(2k + 3)} \\
                    =& \frac{k + 1}{2k + 3} = \frac{k + 1}{2(k + 1) + 1}
                \end{aligned}
            \end{equation*}
        Therefore, if this statement is true for $n = k$, it is also true for $n = k + 1$, and we have already proved it is true for $n = 1$. Therefore, if tossing $n$ coins, the probability of getting odd heads is $\displaystyle\frac{n}{2n + 1}$
        \end{enumerate}
    \end{enumerate}
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
    Follow the steps below to pick an element in stream randomly.
        \begin{enumerate}
            \item First, read the first integer, $a_i$ in the stream, then set a counter variable to 1 and a result value $r = a_i$.
            \item Read the next integer $a_2$ in stream. Increase the counter by $1$, then randomly generate an integer between $1$ and $2$. If $randint(1, 2) = 2$, set $r = a_2$.
            \item Repeat step ii. Every time increase the counter by $1$ and if $randint(1, count) = count$, set $r = a_{count}$.
            \item When reaching the end of the stream, return $r$. If the length of this stream is $n$, then this algorithm could ensure that every integer in this stream has a probability of $\frac{1}{n}$ to be chosen. In this process we only need to keep track of a few variables, so the usage of memory is $O(1)$.
        \end{enumerate}
    \end{enumerate}

\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
        Use induction to prove  that when $n \geq 2$, the expected number of valleys in a random permutation of $\{ 1,2 \cdots n\}$ is $\displaystyle\frac{n+1}{3}$
        \begin{enumerate}
            \item When $n=2$, there are 2 permutations, each has one valley, so the expected number of valley is $\displaystyle\frac{2}{2} = 1 = \frac{2+1}{3}$. This statement is true when $n = 2$.
            \item If this statement is true for $n = k$, we will prove that this statement is also true for $n = k + 1$. The permutations from $1$ to $k + 1$ could be generated by inserting $1$ into the permutations from $2$ to $k + 1$. The expected number of valleys in a random permutation from $2$ to $k + 1$ is $\displaystyle\frac{k + 1}{3}$, and the \textbf{total} number of valleys in all permutations from $2$ to $k + 1$ is just $\displaystyle\frac{k + 1}{3} k!$.
            \item For a random permutation from $2$ to $k + 1$, its length is $k$, and there are $k+1$ slots to insert $1$. Inserting $1$ into some slots will increase the number of valleys, but inserting it into others will not. The pattern is that if we insert $1$ next to an existing valley, this will shift the valley instead of increasing the number of valleys, but if we insert $1$ between non-valleys, the number of valleys will increase. (e.g. For the permutation $(3,2,4)$, $2$ is a valley. If we insert $1$ between $3$ and $2$ or $2$ and $4$, the number of valley is still $1$.  However, if we insert $1$ before $3$ or after $4$, the number of valleys will increase to $2$)
            \item Now we know that for all permutations from $2$ to $k + 1$, there are $(k + 1)k!$ slots and $\displaystyle\frac{k + 1}{3} k!$ valleys. This means that it is expected to have $\displaystyle\frac{k + 1}{3}2k!$ slots across all permutations such that if we insert $1$ in those slots, the number of valleys won't change, and we have $\displaystyle (k+1)k!-\frac{k + 1}{3}2k! = \frac{(k+1)!}{3}$ slots such that if we insert $1$ in this slots, the number of valleys will increase by $1$. Since after inserting $1$ there will be $(k + 1)!$ permutations, the expected number of valleys in a random permutation is expected to increase by $\displaystyle\frac{(k+1)!}{3} \frac{1}{(k+1)!} = \frac{1}{3}$.
            \item Therefore, after the insertion of $1$ into a random permutation from $2$ to $k + 1$, the expected number of valleys is $\displaystyle\frac{(k+1) + 1}{3}$. Which means this statement is also true for $n = k + 1$. Since we hav already proved that it is true for $n = 2$, it is always true for $n \geq 2$. Therefore, the expected number of valleys in a random permutation of $\{ 1,2 \cdots n\}$ is $\displaystyle\frac{n+1}{3}$.
        \end{enumerate}
    \end{enumerate}
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    We know that $P(h_i(a) = h_i(b)) \leq \epsilon$ and $P(\phi_i(a) = \phi_i(b)) \leq \delta$. The hash function $\phi_i \circ h_j$ could be divided in to two steps, the probability of collision in the first step is $\epsilon$, and $\delta$ in the second step. Collision in any step will result in the collision for the entire function. Thus, the probability of collision for this composite function is simply $\epsilon + \phi$, which means $\{\phi_\lambda \circ h_\kappa\}_{(\kappa,\lambda) \in K \times \Lambda}$ is an $\epsilon + \phi$ universal hashing family.
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    According to the analysis of Karger-Stein algorithm, the successful rate of contraction is greater than $\displaystyle\frac{1}{\binom{n}{2}}$. If there are more than $\displaystyle\frac{n(n - 1)}{2} = \binom{n}{2}$ minimum cuts, there are more than $\displaystyle\binom{n}{2}$ ways to divide all nodes into two sets, between which are $k$ edges. However, the successful rate of contracting to each division is greater than $\displaystyle\frac{1}{\binom{n}{2}}$, making the total successful rate greater than $1$, which is a contradiction. Thus, the number of minimum cuts is less than $\displaystyle\binom{n}{2}$.

\end{answer}

\stepcounter{question}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
        Use rolling hash and binary search to solve this problem.
        \begin{enumerate}
            \item First, we should be able to determine if a palindromic substring of a given length $l$ exists. To do this, we iterate through the array and check if $\exists k, hash[k - \frac{l-1}{2} \rightarrow k] = reversehash[k \rightarrow k + \frac{l-1}{2}]$. The hash and reverse-hash function should use the same $i$ and $p$. If such $k$ exists then there exists such palindromic substring. This should take linear time and constant space since making a shift requires constant time and we don't need to create hashtables.
            \item Use binary search to find out the maximum value of $l$. To find maximum value $l$ we need to try $O(\log n)$ values. Return $max(l)$ after we find it.
            \item The total time complexity is $O(n)* O(\log n) = O(n \log n)$. and we only need to store a few constants in this process, so the space complexity is $O(1)$.
        \end{enumerate}
    \end{enumerate}
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
        \item
        \begin{enumerate}
            \item Iterate through this graph (using DFS or BFS) to create an adjacency list. Set up a variable $c$ counting the number of pairs we have to ban with the initial value $0$.
            \item For each vertex, create two hashes: first time hash its adjacency list, second time hash its adjacency with itself. (e.g. for the vertex $5$ in figure $1$, we hash both $[1, 2, 3]$ and $[1 , 2, 3, 5]$). Use the product rolling hash so that the sequence won't affect the result.
            \item After every hashing, insert hashed value into AVL tree. If that key doesn't exist, set $Tree[hashed value] = 1$. If that hashed value already exists as a key in AVL tree, increase $c$ by $Tree[hashed value]$ and then increase $Tree[hashed value]$ by $1$.\\
            (in the previous example, we should insert two key-value pairs in AVL tree: $Tree[hash(1,2,3,5)] = 1$ and $Tree[hash(1,2,3)] = 1$, if later we hash the adjacency list of vertex $4$, $c$ should increase by $1$ since $Tree[hash(1,2,3)] = 1$ and value of $Tree[hash(1,2,3)]$ should then increase one to $2$).
            \item When we complete hashing adjacency list for all vertex, return $c$ as the total number of pairs to ban. In this process we hash $2n$ times with total hash size of $4m + n = O(m)$ and do $2n$ insertions into AVL tree, so the time complexity is $O(n \log n + m)$.
            \item $2n$ hashes are done in this process and for each hash the hash size is less or equal to $n$, which means that the probability of collision is less than $\displaystyle \frac{n}{p}$. However, one collision will result in incorrect output. Use union bound, $P(failure) \leq \displaystyle \frac{n}{p} * 2n$. To make the successful rate greater than $\displaystyle 1 - \frac{1}{n}$, $p$ should satisfy $\displaystyle\frac{1}{n} \geq \frac{2n^2}{p}$, which means $p$ should be greater or equals to $2n^3$.
        \end{enumerate}
    \end{enumerate}
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
        \item
        \begin{enumerate}
            \item
            \begin{equation*}
                \begin{aligned}
                    P\left(Sim(T, S)= \frac{n}{2}\right) &= \frac{\binom{n}{\frac{n}{2}}}{2^n} \\
                    &= \frac{n!}{2^n (\frac{n}{2})!(\frac{n}{2})!} \\
                    &= \frac{\sqrt{2 \pi n} (\frac{n}{e})^n}{2^n \left(\sqrt{\pi n} (\frac{n}{2e})^\frac{n}{2}\right)^2} \\
                    &= \sqrt{\frac{2}{\pi n}}
                \end{aligned}
            \end{equation*}
            \item
            If we repeat generating a random binary string $T$ of length $n$ for $\displaystyle\sqrt{\frac{\pi n}{2}}$ times, the probability of success is $\displaystyle 1-\left(1-\sqrt{\frac{2}{\pi n}}\right)^{\displaystyle\sqrt\frac{\pi n}{2}} \approx 1 - \frac{1}{e}$, which meets the requirement. Since the time complexity of $reducedSim()$ is $O(n)$ and we try $\displaystyle O(n^{\frac{1}{2}})$ times, the total time complexity is $\displaystyle(O(n^{\frac{3}{2}}))$
        \end{enumerate}
        \item
        Solve this problem using the following steps:
        \begin{enumerate}
            \item
            Construct two lists $C_1, C_2$ to represent two categories of indexes: indexes such that $S[i] = T[i]$ and indexes such that $S[i] \neq T[i]$. For now we don't know which list represents which category. Put $1$ in to $C_1$
            \item
            Switch the value of $T[1]$ and $T[2]$ to get $T^\prime$. If $reducedSim(T^\prime) = 0$, then $1$ and $2$ belongs to the same category, that is, either $T[1] = S[1]$ and $T[2] = S[2]$ or $T[1] \neq S[1]$ and $T[2] \neq S[2]$. If $1$ and $2$ belongs to the same category, put $2$ into $C_1$. If $\displaystyle reducedSim(T^\prime) = \frac{n}{2}$, then $1$ and $2$ belongs to different categories, put $2$ into $C_1$.
            \item
            Iterate through the indexes, switch the value of $T[1]$ and $T[k]$ to examine if $1$ and $k$ belongs to the same category by checking the value of $reducedSim(T^\prime)$.
            \item
            After iteration, now both $C_1$ and $C_2$ have $\displaystyle \frac{n}{2}$ elements. Change all values in $T$ at indexes in $C_1$ to get $T^*$and try $reducedSim(T^*)$, if $reducedSim(T^*) = n$ then $T^*$ is $S$. If $reducedSim(T^*) = 0$, change all values in $T$ at indexes in $C_2$, then we get $S$.
            \item
            In this process, $reducedSim()$ is called $O(n)$ times, the total time complexity is $O(n^2)$.
        \end{enumerate}
    \end{enumerate}
\end{answer}

\begin{question}
\end{question}
%% Student: put your answer between the next two lines.
\begin{answer}
    \begin{enumerate}
        \item Set up a $2$-dimension DP table to solve this problem.
        \begin{enumerate}
            \item
            The table should have size of $26 \times n$, where $n$ is the length of the input string. $DP[\alpha][i]= \zeta_\alpha$ for index $i$.
            \item
            Let $S$ be the input string. Iterate through the last column of the table. Set $DP[\alpha][n] = 1$ for $\alpha = S_n$ and $DP[\alpha][n] = None$ for $\alpha \neq S_n$.
            \item
            Then iterate through the column before the last column. Fill the entries by following rules:
            \begin{equation*}
                DP \lbrack \alpha \rbrack \lbrack i \rbrack =
                \begin{cases}
                    1,\, \alpha = S_i \\
                    DP \lbrack \alpha \rbrack \lbrack i+1 \rbrack + 1,\, \alpha \neq S_i \text{ and } DP \lbrack \alpha \rbrack \lbrack i+1 \rbrack \neq None \\
                    None,\, \alpha \neq S_i \text{ and } DP \lbrack \alpha \rbrack \lbrack i+1 \rbrack = None
                \end{cases}
            \end{equation*}
            \item
            After finish filling the DP table, we could get $\zeta_\alpha$ for any given $i, j$ in $O(1)$:
            \begin{equation*}
                \zeta_\alpha =
                \begin{cases}
                    DP \lbrack \alpha \rbrack \lbrack i \rbrack,\, DP \lbrack \alpha \rbrack \lbrack i \rbrack \neq None \text{ and } DP \lbrack \alpha \rbrack \lbrack i \rbrack \leq j - i + 1\\
                    DNE,\, otherwise
                \end{cases}
            \end{equation*}
            \item We need to fill $26n$ entries and filling each entry takes $O(1)$. Thus the total time complexity is $O(n)$.
        \end{enumerate}
        \item
        \begin{enumerate}
            \item
            We could just maintain a permutation list of length $26$ with its all initial values set to $None$ to indicate what $\pi_\alpha$ is for every $\alpha$, and maintain an indicator list of length $26$ with its a; value set to $False$ to indicate whether their exists $\alpha$ such that $\pi_\alpha = \beta$ for every $\beta$.
            \item
            Then iterate through all letters in the first substring, and for every $\alpha$ in the first string, check the permutation list to see if $permutationlist[\alpha]$ is $None$. If it is not $None$, check if the corresponding letter in the second string equals to $\pi_\alpha$ and return $NO$ if not. If $\pi_\alpha$ doesn't exist, we could find $\zeta_\alpha$, and get $\pi_\alpha$. Let $\beta = \pi_\alpha$. Get the value of $indicatorlist[\beta]$. If it is $True$, it means that this letter $\beta$ has already been taken by another $\alpha^\prime$ such that $\pi_{\alpha^\prime} = \beta$, so we should return $NO$ in this case. If $indicatorlist[\beta] = False$, then we could set $\pi_\alpha = permutationlist[\alpha] = \beta$, set $indicatorlist[\beta]$ to $True$ and move to the next letter. All those could be done in $O(1)$ time.
            \item
            If we successfully reach the end of the first string(and also the end of the second string), return $YES$. This takes $O(n)$ time in total and there's no need for a Monte Carlo algorithm.
            \item
            (According to the definition the equivalent relationship only requires the permutation that transform $X$ to $Y$ but not $Y$ to $X$. In the previous steps I assume a bilateral relationship (permutations transform $X$ to $Y$ and $Y$ to $X$ both exist). If the equivalent relationship really only requires unilateral transformation, simply remove that indicator list and relevant checking steps and the algorithm should work)
        \end{enumerate}

    \end{enumerate}
\end{answer}

\end{document}
\endinput
%%
%% End of file `ps4.ans.tex'.
